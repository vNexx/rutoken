/*************************************************************************
* Rutoken                                                                *
* Copyright (c) 2003-2017, CJSC Aktiv-Soft. All rights reserved.         *
* Подробная информация:  http://www.rutoken.ru                           *
*------------------------------------------------------------------------*
* Данный пример демонстрирует создание запроса на получение сертификата  *
* в формате PKCS#10 с помощью pkicore. Для успешного выполнения          *
* программы на токене должен находиться секретный ключ. Для создания     *
* ключевой пары на токене можно воспользоваться примером                 *
* GenerateKeyPair. Запрос на получение сертификата в формате PEM         *
* записывается в файл pkcs10.pem.                                        *
*************************************************************************/

#include <common.h>

using namespace std;
using namespace rutoken::pkicore;

int main()
{
	try {
		cout << boolalpha;

		/**********************************************************************
		* Инициализируем pkicore, передав путь до директории с библиотекой    *
		* rtPKCS11ECP.                                                        *
		**********************************************************************/
		rutoken::pkicore::initialize(".");
		SCOPE_EXIT() {
			/**********************************************************************
			* Завершаем работу с pkicore при выходе из текущего блока.            *
			**********************************************************************/
			rutoken::pkicore::deinitialize();
		};

		/**********************************************************************
		* Получаем список подключенных устройств и продолжаем работу с первым *
		* доступным устройством.                                              *
		**********************************************************************/
		auto devices = Pkcs11Device::enumerate();
		if (devices.empty()) {
			throw runtime_error("There must be at least one device connected");
		}

		auto device = move(devices.front());

		/**********************************************************************
		* Аутентифицируемся на устройстве.                                    *
		**********************************************************************/
		device.login("12345678");
		SCOPE_EXIT(&device) {
			/**********************************************************************
			* Сбрасываем права доступа при выходе из текущего блока.              *
			**********************************************************************/
			device.logout();
		};

		/**********************************************************************
		* Получаем список ключей на устройстве и продолжаем работу с первым   *
		* найденным                                                           *
		**********************************************************************/
		auto keys = device.enumeratePrivateKeys();
		if (keys.empty()) {
			throw runtime_error("There must be at least one key on device");
		}

		auto key = move(keys.front());

		/**********************************************************************
		* Создаем субъект сертификата и заполняем его поля.                   *
		**********************************************************************/
		X500Dn subject;
		subject.setRdn(X500Dn::RdnId::commonName, "commonName")
		.setRdn(X500Dn::RdnId::surname, "surname")
		.setRdn(X500Dn::RdnId::givenName, "givenName1");

		/**********************************************************************
		* Создаем key usage расширение сертификата и задаем его значение.    *
		**********************************************************************/
		X509KeyUsage keyUsage;
		keyUsage.addOption(X509KeyUsage::Option::digitalSignature)
		.addOption(X509KeyUsage::Option::keyAgreement)
		.setCritical();


		/**********************************************************************
		* Задаем поля запроса на получение сертификата.                       *
		**********************************************************************/
		Pkcs10RequestInfo info;
		//
		unsigned char customExtensionASN1Data[] = {
			0x0C, 0x33, 0x30, 0x30, 0x43, 0x41, 0x30, 0x31,
			0x37, 0x38, 0x69, 0xD0, 0x90, 0xD0, 0xA0, 0xD0,
			0x9C, 0x20, 0xD0, 0x98, 0xD0, 0xBD, 0xD0, 0xB8,
			0xD1, 0x86, 0xD0, 0xB8, 0xD0, 0xB0, 0xD0, 0xBB,
			0xD0, 0xB8, 0xD0, 0xB7, 0xD0, 0xB0, 0xD1, 0x86,
			0xD0, 0xB8, 0xD0, 0xB8, 0x20, 0xD0, 0xA2, 0xD0,
			0x95, 0xD0, 0xA1, 0xD0, 0xA2,
		};
		//

		info.setSubject(move(subject))
		.setExtension(move(keyUsage));

		info.setCustomExtension("1.2.643.2.2.34.6", customExtensionASN1Data, sizeof(customExtensionASN1Data), false);

		/**********************************************************************
		* Создаем PKCS#10 запрос на получение сертификата.                    *
		**********************************************************************/
		auto request = createPkcs10Request(key, info);
		auto pem = request.toPem();

		/**********************************************************************
		* Записываем запрос в файл.                                           *
		**********************************************************************/
		const auto fileName = "pkcs10.pem";

		cout << "Writing certification request to " << fileName << endl;

		writeFile(fileName, pem.data(), pem.size());
	} catch (const exception& e) {
		cerr << e.what() << endl;
		return 1;
	}

	return 0;
}
